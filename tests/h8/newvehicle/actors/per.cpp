/*
 * Project: E.R.I.K.A. - Embedded Real tIme Kernel Architecture
 *
 * http://erika.sssup.it
 *
 * Copyright (C) 2002 Davide Cantini
 *
 * This program is distributed under the GPL license contained into
 * the license.txt file on the E.R.I.K.A. root directory.
 */

extern "C" {
#include "erika.h"
#include "osekirq.h"
}

#include "code.hpp"

extern "C" {

/****************************************************************************
  Periods
****************************************************************************/

/* this handler is executed when ON/OFF button falls down */
ISR(ONOFFbutton_handler)
{       
  /* the system goes in sleep state. to be woken up, it has to be
     reset, and this happens at the next irq., that causes the
     handler to execute the else branch of this if statement. */
  evt_post(EVT_BTN_ONOFF);
}




/* this handler is called every 2000us (when T16OCRB matchs FRC). 
   ERIKA uses this interrupt for:
   - handling motors (duty cicle)
   - handling sound (generated by output of 8bit timer0)
   - calling this handler :-)
*/
void ERIKA_timerB_user_function(void)
{
  ERIKA_counter_tick(counter0);
}




ISR(ADI_handler)
{
  ERIKA_UINT16 a, b;
  int temp;

  ERIKA_ad_stop();    

  a=(ERIKA_ad_get_port3()>>(6+LIGHT_TOLERANCE))+OFFSET_ERR;	
  // NOTE: one sensor read OFFSET_ERR units less than other.
  //       suppose it is S1, so offset is summed to it
  b=(ERIKA_ad_get_port2()>>(6+LIGHT_TOLERANCE)); 
    
  /* send the token to the conversion actor */
  source_o1.broadcast(a, temp);
  source_o2.broadcast(b, temp);

  /* when AD conversion ended, activate thread for control (if setup done)*/
  if (mm.getMode()==MODE_NORMAL ||
      mm.getMode()==MODE_SLOWSPEED ||
      mm.getMode()==MODE_FAULT1)
    CPP_thread1.ActivateTask();
    
  /* turn on red light for sensor */
  Port6 |= ~0xFC;
    
  /* reset A/D end-conversion flag */
  ERIKA_ad_reset_end_flag();
}



//PJ
int mynumber;

ISR(RUNbutton_handler)
{
  // PJ
  mynumber = !mynumber;
  evt_post(EVT_BTN_RUN);
}



/****************************************************************************
  IR layer indication
****************************************************************************/

static ERIKA_UINT8 PER_IR_command = 0;

static int xxx=0;
void PER_IR_indication(ERIKA_UINT8 len, ERIKA_UINT8 *data)
{
  //  ERIKA_lcd_write_num(6000+ (xxx++)); // this shows that send.c sends more than 1 byte
  PER_IR_command = *data;
  CPP_thread2.ActivateTask();
  ERIKA_IR_receive_enable();
}

ERIKA_UINT8 PER_get_last_command(void)
{
  return PER_IR_command;
}


/****************************************************************************
  Peripheral initialization
****************************************************************************/

void PER_init(void)
{
  /* external interrupts generated once when you press the button (and not *
   * for all the time you are are pressing the button)                     */
  ERIKA_button_irq_mode(ONOFF_EDGE_RUN_EDGE);

  /* select A/D channel and mode */
  ERIKA_ad_select (AD_PORT32_SCAN_ACT_ACT);
    
  /* install IRQ handlers */
  ERIKA_set_handler(ONOFFBUTTON_IRQ, ONOFFbutton_handler);   
  ERIKA_set_handler(RUNBUTTON_IRQ, RUNbutton_handler);
  ERIKA_set_handler(ADI_IRQ, ADI_handler);
    
  /* enable external interrupt sources */ 
  ERIKA_enable_irq(ONOFFBUTTON_IRQ);  
  ERIKA_enable_irq(RUNBUTTON_IRQ);        
  ERIKA_enable_irq(ADI_IRQ);
    
  /* IR configuration */
  ERIKA_IR_result(PER_IR_indication);
  ERIKA_IR_start();
  ERIKA_IR_receive_enable();
}

}
